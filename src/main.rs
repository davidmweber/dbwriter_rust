extern crate chrono;
#[macro_use]
extern crate diesel;

use std::env;

use actix_web::{App, HttpRequest, HttpServer, web};
use chrono::prelude::*;
use diesel::{r2d2, RunQueryDsl};
use diesel::pg::PgConnection;
use diesel::r2d2::ConnectionManager;
use dotenv::dotenv;

use schema::sample;

pub mod schema;

/*
 * Map structs over the schema in schema.rs that was generated by the database migration
 */
#[derive(Insertable, Queryable)]
#[table_name = "sample"]
pub struct AddSample<'a> {
    name: &'a str,
    timestamp: NaiveDateTime,
    v0: f32,
    v1: f32,
}

/*
 * Our ReST API
 */
async fn hello(req: HttpRequest) -> &'static str {
    "Hello world!"
}

// Returns all the samples in the database
async fn get_samples(req: HttpRequest) -> &'static str {
    "bla"
}

async fn get_sample(req: HttpRequest) -> &'static str {
    "bla"
}

async fn write_samples(req: HttpRequest) -> &'static str {
    "bla"
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenv().ok();

    // Set up a connection pool to the database
    let db_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(db_url);
    let pool = r2d2::Pool::builder()
        .max_size(12)
        .build(manager)
        .expect(&format!("Error connecting to database"));

    // Put some stuff into our database
    for i in 0..10 {
        let conn = pool.get().unwrap(); // Grab a separate connection for each iteration
        let record = AddSample {
            name: "frobnicator_manifold_pressure",
            timestamp: Utc::now().naive_utc(),
            v0: i as f32,
            v1: (2 * i) as f32,
        };
        let res = diesel::insert_into(sample::dsl::sample)
            .values(record)
            .execute(&conn);
            assert_eq!(res, Ok(1)); // Will be Err(something) if there was a problem
    }
    //let results = sample.ilter

    // Start up the HTTP server, set up the routes and and just block on its completion
    HttpServer::new(|| {  // This is a lambda function with zero arguments
        App::new()
            .route("/", web::get().to(hello))
            .route("/samples", web::get().to(get_samples))
            .route("/samples/{id}", web::get().to(get_sample))
            .route("/samples", web::post().to(write_samples))
    })
    .bind(("127.0.0.1", 8080))?
    .run()
    .await
}
